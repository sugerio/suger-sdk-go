/*
Suger API

CRUD operations on a set of resources, including organizations, products, offers, entitlements, usage record groups for meterting, etc.

API version: 1.0
Contact: support@suger.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package suger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ReportAPIService ReportAPI service
type ReportAPIService service

type ApiGetRevenueReportRequest struct {
	ctx        context.Context
	ApiService *ReportAPIService
	orgId      string
	data       *GetRevenueReportParams
}

// Get Revenue Report Params
func (r ApiGetRevenueReportRequest) Data(data GetRevenueReportParams) ApiGetRevenueReportRequest {
	r.data = &data
	return r
}

func (r ApiGetRevenueReportRequest) Execute() (*RevenueReport, *http.Response, error) {
	return r.ApiService.GetRevenueReportExecute(r)
}

/*
GetRevenueReport get revenue report

Get the revenue report of the given organization, product, entitlement, or buyer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Organization ID
	@return ApiGetRevenueReportRequest
*/
func (a *ReportAPIService) GetRevenueReport(ctx context.Context, orgId string) ApiGetRevenueReportRequest {
	return ApiGetRevenueReportRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
	}
}

// Execute executes the request
//
//	@return RevenueReport
func (a *ReportAPIService) GetRevenueReportExecute(r ApiGetRevenueReportRequest) (*RevenueReport, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RevenueReport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportAPIService.GetRevenueReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/org/{orgId}/revenueReport"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDailyRevenueRecordsRequest struct {
	ctx           context.Context
	ApiService    *ReportAPIService
	orgId         string
	partner       *string
	productId     *string
	buyerId       *string
	entitlementId *string
	startDate     *string
	endDate       *string
}

// Cloud Partner
func (r ApiListDailyRevenueRecordsRequest) Partner(partner string) ApiListDailyRevenueRecordsRequest {
	r.partner = &partner
	return r
}

// Filter daily revenue records by the given product ID
func (r ApiListDailyRevenueRecordsRequest) ProductId(productId string) ApiListDailyRevenueRecordsRequest {
	r.productId = &productId
	return r
}

// Filter daily revenue records by the given buyer ID
func (r ApiListDailyRevenueRecordsRequest) BuyerId(buyerId string) ApiListDailyRevenueRecordsRequest {
	r.buyerId = &buyerId
	return r
}

// Filter daily revenue records by the given entitlement ID
func (r ApiListDailyRevenueRecordsRequest) EntitlementId(entitlementId string) ApiListDailyRevenueRecordsRequest {
	r.entitlementId = &entitlementId
	return r
}

// start date (UTC) in YYYY-MM-DD format, default is 30 days before the endDate
func (r ApiListDailyRevenueRecordsRequest) StartDate(startDate string) ApiListDailyRevenueRecordsRequest {
	r.startDate = &startDate
	return r
}

// end date (UTC) in YYYY-MM-DD format, default is today
func (r ApiListDailyRevenueRecordsRequest) EndDate(endDate string) ApiListDailyRevenueRecordsRequest {
	r.endDate = &endDate
	return r
}

func (r ApiListDailyRevenueRecordsRequest) Execute() ([]RevenueRecord, *http.Response, error) {
	return r.ApiService.ListDailyRevenueRecordsExecute(r)
}

/*
ListDailyRevenueRecords list daily revenue records

list daily revenue records for the given organization, partner, entitlement, or buyer, within the given date range.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Organization ID
	@return ApiListDailyRevenueRecordsRequest
*/
func (a *ReportAPIService) ListDailyRevenueRecords(ctx context.Context, orgId string) ApiListDailyRevenueRecordsRequest {
	return ApiListDailyRevenueRecordsRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
	}
}

// Execute executes the request
//
//	@return []RevenueRecord
func (a *ReportAPIService) ListDailyRevenueRecordsExecute(r ApiListDailyRevenueRecordsRequest) ([]RevenueRecord, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RevenueRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportAPIService.ListDailyRevenueRecords")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/org/{orgId}/dailyRevenueRecord"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.partner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partner", r.partner, "", "")
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "", "")
	}
	if r.buyerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyerId", r.buyerId, "", "")
	}
	if r.entitlementId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementId", r.entitlementId, "", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRevenueRecordDetailsRequest struct {
	ctx           context.Context
	ApiService    *ReportAPIService
	orgId         string
	partner       string
	productId     *string
	buyerId       *string
	entitlementId *string
	startDate     *string
	endDate       *string
	limit         *int32
	offset        *int32
}

// Filter revenue record details by the given product ID
func (r ApiListRevenueRecordDetailsRequest) ProductId(productId string) ApiListRevenueRecordDetailsRequest {
	r.productId = &productId
	return r
}

// Filter revenue record details by the given buyer ID
func (r ApiListRevenueRecordDetailsRequest) BuyerId(buyerId string) ApiListRevenueRecordDetailsRequest {
	r.buyerId = &buyerId
	return r
}

// Filter revenue record details by the given entitlement ID
func (r ApiListRevenueRecordDetailsRequest) EntitlementId(entitlementId string) ApiListRevenueRecordDetailsRequest {
	r.entitlementId = &entitlementId
	return r
}

// start date (UTC) in YYYY-MM-DD format, default is 30 days before the endDate
func (r ApiListRevenueRecordDetailsRequest) StartDate(startDate string) ApiListRevenueRecordDetailsRequest {
	r.startDate = &startDate
	return r
}

// end date (UTC) in YYYY-MM-DD format, default is today
func (r ApiListRevenueRecordDetailsRequest) EndDate(endDate string) ApiListRevenueRecordDetailsRequest {
	r.endDate = &endDate
	return r
}

// List pagination size, default 1000, max value is 1000
func (r ApiListRevenueRecordDetailsRequest) Limit(limit int32) ApiListRevenueRecordDetailsRequest {
	r.limit = &limit
	return r
}

// List pagination offset, default 0
func (r ApiListRevenueRecordDetailsRequest) Offset(offset int32) ApiListRevenueRecordDetailsRequest {
	r.offset = &offset
	return r
}

func (r ApiListRevenueRecordDetailsRequest) Execute() (*ListRevenueRecordDetailsResponse, *http.Response, error) {
	return r.ApiService.ListRevenueRecordDetailsExecute(r)
}

/*
ListRevenueRecordDetails list revenue record details

list the raw revenue record details for the given organization, partner, product, entitlement, or buyer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Organization ID
	@param partner Cloud Partner
	@return ApiListRevenueRecordDetailsRequest
*/
func (a *ReportAPIService) ListRevenueRecordDetails(ctx context.Context, orgId string, partner string) ApiListRevenueRecordDetailsRequest {
	return ApiListRevenueRecordDetailsRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
		partner:    partner,
	}
}

// Execute executes the request
//
//	@return ListRevenueRecordDetailsResponse
func (a *ReportAPIService) ListRevenueRecordDetailsExecute(r ApiListRevenueRecordDetailsRequest) (*ListRevenueRecordDetailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListRevenueRecordDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportAPIService.ListRevenueRecordDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/org/{orgId}/partner/{partner}/revenueRecordDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partner"+"}", url.PathEscape(parameterValueToString(r.partner, "partner")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "", "")
	}
	if r.buyerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyerId", r.buyerId, "", "")
	}
	if r.entitlementId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementId", r.entitlementId, "", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRevenueRecordsRequest struct {
	ctx           context.Context
	ApiService    *ReportAPIService
	orgId         string
	partner       string
	productId     *string
	entitlementId *string
	buyerId       *string
	startDate     *string
	endDate       *string
	limit         *int32
	offset        *int32
}

// Filter revenue records by the given product ID
func (r ApiListRevenueRecordsRequest) ProductId(productId string) ApiListRevenueRecordsRequest {
	r.productId = &productId
	return r
}

// Filter revenue records by the given entitlement ID
func (r ApiListRevenueRecordsRequest) EntitlementId(entitlementId string) ApiListRevenueRecordsRequest {
	r.entitlementId = &entitlementId
	return r
}

// Filter revenue records by the given buyer ID
func (r ApiListRevenueRecordsRequest) BuyerId(buyerId string) ApiListRevenueRecordsRequest {
	r.buyerId = &buyerId
	return r
}

// start date (UTC) in YYYY-MM-DD format, default is 30 days before the endDate
func (r ApiListRevenueRecordsRequest) StartDate(startDate string) ApiListRevenueRecordsRequest {
	r.startDate = &startDate
	return r
}

// end date (UTC) in YYYY-MM-DD format, default is today
func (r ApiListRevenueRecordsRequest) EndDate(endDate string) ApiListRevenueRecordsRequest {
	r.endDate = &endDate
	return r
}

// List pagination size, default 1000, max value is 1000
func (r ApiListRevenueRecordsRequest) Limit(limit int32) ApiListRevenueRecordsRequest {
	r.limit = &limit
	return r
}

// List pagination offset, default 0
func (r ApiListRevenueRecordsRequest) Offset(offset int32) ApiListRevenueRecordsRequest {
	r.offset = &offset
	return r
}

func (r ApiListRevenueRecordsRequest) Execute() (*ListRevenueRecordsResponse, *http.Response, error) {
	return r.ApiService.ListRevenueRecordsExecute(r)
}

/*
ListRevenueRecords list revenue records

list the revenue records for the given organization, product, entitlement, or buyer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Organization ID
	@param partner Cloud Partner
	@return ApiListRevenueRecordsRequest
*/
func (a *ReportAPIService) ListRevenueRecords(ctx context.Context, orgId string, partner string) ApiListRevenueRecordsRequest {
	return ApiListRevenueRecordsRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
		partner:    partner,
	}
}

// Execute executes the request
//
//	@return ListRevenueRecordsResponse
func (a *ReportAPIService) ListRevenueRecordsExecute(r ApiListRevenueRecordsRequest) (*ListRevenueRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListRevenueRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportAPIService.ListRevenueRecords")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/org/{orgId}/partner/{partner}/revenueRecord"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partner"+"}", url.PathEscape(parameterValueToString(r.partner, "partner")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "", "")
	}
	if r.entitlementId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementId", r.entitlementId, "", "")
	}
	if r.buyerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyerId", r.buyerId, "", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageMeteringDailyRecordsRequest struct {
	ctx           context.Context
	ApiService    *ReportAPIService
	orgId         string
	partner       string
	buyerId       *string
	entitlementId *string
	startDate     *string
	endDate       *string
	limit         *int32
	offset        *int32
}

// Filter usage metering daily records by the given buyer ID
func (r ApiListUsageMeteringDailyRecordsRequest) BuyerId(buyerId string) ApiListUsageMeteringDailyRecordsRequest {
	r.buyerId = &buyerId
	return r
}

// Filter usage metering daily records by the given entitlement ID
func (r ApiListUsageMeteringDailyRecordsRequest) EntitlementId(entitlementId string) ApiListUsageMeteringDailyRecordsRequest {
	r.entitlementId = &entitlementId
	return r
}

// start date (UTC) in YYYY-MM-DD format, default is 30 days before the endDate
func (r ApiListUsageMeteringDailyRecordsRequest) StartDate(startDate string) ApiListUsageMeteringDailyRecordsRequest {
	r.startDate = &startDate
	return r
}

// end date (UTC) in YYYY-MM-DD format, default is today
func (r ApiListUsageMeteringDailyRecordsRequest) EndDate(endDate string) ApiListUsageMeteringDailyRecordsRequest {
	r.endDate = &endDate
	return r
}

// List pagination size, default 1000, max value is 1000
func (r ApiListUsageMeteringDailyRecordsRequest) Limit(limit int32) ApiListUsageMeteringDailyRecordsRequest {
	r.limit = &limit
	return r
}

// List pagination offset, default 0
func (r ApiListUsageMeteringDailyRecordsRequest) Offset(offset int32) ApiListUsageMeteringDailyRecordsRequest {
	r.offset = &offset
	return r
}

func (r ApiListUsageMeteringDailyRecordsRequest) Execute() (*ListUsageMeteringDailyRecordsResponse, *http.Response, error) {
	return r.ApiService.ListUsageMeteringDailyRecordsExecute(r)
}

/*
ListUsageMeteringDailyRecords list usage metering daily records

list the daily records of the usage metering from the cloud marketplace for the given organization, entitlement, or buyer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Organization ID
	@param partner Filter by the Cloud Partner
	@return ApiListUsageMeteringDailyRecordsRequest
*/
func (a *ReportAPIService) ListUsageMeteringDailyRecords(ctx context.Context, orgId string, partner string) ApiListUsageMeteringDailyRecordsRequest {
	return ApiListUsageMeteringDailyRecordsRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
		partner:    partner,
	}
}

// Execute executes the request
//
//	@return ListUsageMeteringDailyRecordsResponse
func (a *ReportAPIService) ListUsageMeteringDailyRecordsExecute(r ApiListUsageMeteringDailyRecordsRequest) (*ListUsageMeteringDailyRecordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListUsageMeteringDailyRecordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportAPIService.ListUsageMeteringDailyRecords")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/org/{orgId}/partner/{partner}/usageMeteringDailyRecord"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partner"+"}", url.PathEscape(parameterValueToString(r.partner, "partner")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.buyerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyerId", r.buyerId, "", "")
	}
	if r.entitlementId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementId", r.entitlementId, "", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
