/*
Suger API

CRUD operations on a set of resources, including organizations, products, offers, entitlements, usage record groups for meterting, etc.

API version: 1.0
Contact: support@suger.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
)

// checks if the TypesUsageRecord type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TypesUsageRecord{}

// TypesUsageRecord struct for TypesUsageRecord
type TypesUsageRecord struct {
	// The CustomerIdentifier is obtained through the ResolveCustomer operation and represents an individual buyer in your application.  This member is required.
	CustomerIdentifier *string `json:"customerIdentifier,omitempty"`
	// During the process of registering a product on AWS Marketplace, dimensions are specified. These represent different units of value in your application.  This member is required.
	Dimension *string `json:"dimension,omitempty"`
	// The quantity of usage consumed by the customer for the given dimension and time. Defaults to 0 if not specified.
	Quantity *int32 `json:"quantity,omitempty"`
	// Timestamp, in UTC, for which the usage is being reported. Your application can meter usage for up to one hour in the past. Make sure the timestamp value is not before the start of the software usage.  This member is required.
	Timestamp *string `json:"timestamp,omitempty"`
	// The set of UsageAllocations to submit. The sum of all UsageAllocation quantities must equal the Quantity of the UsageRecord .
	UsageAllocations []TypesUsageAllocation `json:"usageAllocations,omitempty"`
}

// NewTypesUsageRecord instantiates a new TypesUsageRecord object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTypesUsageRecord() *TypesUsageRecord {
	this := TypesUsageRecord{}
	return &this
}

// NewTypesUsageRecordWithDefaults instantiates a new TypesUsageRecord object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTypesUsageRecordWithDefaults() *TypesUsageRecord {
	this := TypesUsageRecord{}
	return &this
}

// GetCustomerIdentifier returns the CustomerIdentifier field value if set, zero value otherwise.
func (o *TypesUsageRecord) GetCustomerIdentifier() string {
	if o == nil || IsNil(o.CustomerIdentifier) {
		var ret string
		return ret
	}
	return *o.CustomerIdentifier
}

// GetCustomerIdentifierOk returns a tuple with the CustomerIdentifier field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TypesUsageRecord) GetCustomerIdentifierOk() (*string, bool) {
	if o == nil || IsNil(o.CustomerIdentifier) {
		return nil, false
	}
	return o.CustomerIdentifier, true
}

// HasCustomerIdentifier returns a boolean if a field has been set.
func (o *TypesUsageRecord) HasCustomerIdentifier() bool {
	if o != nil && !IsNil(o.CustomerIdentifier) {
		return true
	}

	return false
}

// SetCustomerIdentifier gets a reference to the given string and assigns it to the CustomerIdentifier field.
func (o *TypesUsageRecord) SetCustomerIdentifier(v string) {
	o.CustomerIdentifier = &v
}

// GetDimension returns the Dimension field value if set, zero value otherwise.
func (o *TypesUsageRecord) GetDimension() string {
	if o == nil || IsNil(o.Dimension) {
		var ret string
		return ret
	}
	return *o.Dimension
}

// GetDimensionOk returns a tuple with the Dimension field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TypesUsageRecord) GetDimensionOk() (*string, bool) {
	if o == nil || IsNil(o.Dimension) {
		return nil, false
	}
	return o.Dimension, true
}

// HasDimension returns a boolean if a field has been set.
func (o *TypesUsageRecord) HasDimension() bool {
	if o != nil && !IsNil(o.Dimension) {
		return true
	}

	return false
}

// SetDimension gets a reference to the given string and assigns it to the Dimension field.
func (o *TypesUsageRecord) SetDimension(v string) {
	o.Dimension = &v
}

// GetQuantity returns the Quantity field value if set, zero value otherwise.
func (o *TypesUsageRecord) GetQuantity() int32 {
	if o == nil || IsNil(o.Quantity) {
		var ret int32
		return ret
	}
	return *o.Quantity
}

// GetQuantityOk returns a tuple with the Quantity field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TypesUsageRecord) GetQuantityOk() (*int32, bool) {
	if o == nil || IsNil(o.Quantity) {
		return nil, false
	}
	return o.Quantity, true
}

// HasQuantity returns a boolean if a field has been set.
func (o *TypesUsageRecord) HasQuantity() bool {
	if o != nil && !IsNil(o.Quantity) {
		return true
	}

	return false
}

// SetQuantity gets a reference to the given int32 and assigns it to the Quantity field.
func (o *TypesUsageRecord) SetQuantity(v int32) {
	o.Quantity = &v
}

// GetTimestamp returns the Timestamp field value if set, zero value otherwise.
func (o *TypesUsageRecord) GetTimestamp() string {
	if o == nil || IsNil(o.Timestamp) {
		var ret string
		return ret
	}
	return *o.Timestamp
}

// GetTimestampOk returns a tuple with the Timestamp field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TypesUsageRecord) GetTimestampOk() (*string, bool) {
	if o == nil || IsNil(o.Timestamp) {
		return nil, false
	}
	return o.Timestamp, true
}

// HasTimestamp returns a boolean if a field has been set.
func (o *TypesUsageRecord) HasTimestamp() bool {
	if o != nil && !IsNil(o.Timestamp) {
		return true
	}

	return false
}

// SetTimestamp gets a reference to the given string and assigns it to the Timestamp field.
func (o *TypesUsageRecord) SetTimestamp(v string) {
	o.Timestamp = &v
}

// GetUsageAllocations returns the UsageAllocations field value if set, zero value otherwise.
func (o *TypesUsageRecord) GetUsageAllocations() []TypesUsageAllocation {
	if o == nil || IsNil(o.UsageAllocations) {
		var ret []TypesUsageAllocation
		return ret
	}
	return o.UsageAllocations
}

// GetUsageAllocationsOk returns a tuple with the UsageAllocations field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TypesUsageRecord) GetUsageAllocationsOk() ([]TypesUsageAllocation, bool) {
	if o == nil || IsNil(o.UsageAllocations) {
		return nil, false
	}
	return o.UsageAllocations, true
}

// HasUsageAllocations returns a boolean if a field has been set.
func (o *TypesUsageRecord) HasUsageAllocations() bool {
	if o != nil && !IsNil(o.UsageAllocations) {
		return true
	}

	return false
}

// SetUsageAllocations gets a reference to the given []TypesUsageAllocation and assigns it to the UsageAllocations field.
func (o *TypesUsageRecord) SetUsageAllocations(v []TypesUsageAllocation) {
	o.UsageAllocations = v
}

func (o TypesUsageRecord) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o TypesUsageRecord) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.CustomerIdentifier) {
		toSerialize["customerIdentifier"] = o.CustomerIdentifier
	}
	if !IsNil(o.Dimension) {
		toSerialize["dimension"] = o.Dimension
	}
	if !IsNil(o.Quantity) {
		toSerialize["quantity"] = o.Quantity
	}
	if !IsNil(o.Timestamp) {
		toSerialize["timestamp"] = o.Timestamp
	}
	if !IsNil(o.UsageAllocations) {
		toSerialize["usageAllocations"] = o.UsageAllocations
	}
	return toSerialize, nil
}

type NullableTypesUsageRecord struct {
	value *TypesUsageRecord
	isSet bool
}

func (v NullableTypesUsageRecord) Get() *TypesUsageRecord {
	return v.value
}

func (v *NullableTypesUsageRecord) Set(val *TypesUsageRecord) {
	v.value = val
	v.isSet = true
}

func (v NullableTypesUsageRecord) IsSet() bool {
	return v.isSet
}

func (v *NullableTypesUsageRecord) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTypesUsageRecord(val *TypesUsageRecord) *NullableTypesUsageRecord {
	return &NullableTypesUsageRecord{value: val, isSet: true}
}

func (v NullableTypesUsageRecord) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTypesUsageRecord) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
